this.lastPrice = price;
                this.lastTradeTime = tradeTime;
                this.ticks.push(tick);
                
                // Store ticks for time-based analysis
                this.updateTickAnalysis(tick);
                
                if(direction > 0) this.upticks++;
                else if(direction < 0) this.downticks++;
                
                // Track bot positional bias
                this.updateBotPositionBias(tick);
                
                // Keep only last 100 ticks for performance
                if(this.ticks.length > 100) {
                    this.ticks.shift();
                }
                
                this.analyzeBotActivity();
                this.updateActivityHistory();
                this.updateTickStrengthAnalysis();
                this.updateUI();<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Activity Radar</title>
    <style>
        body {
            font-family: 'Consolas', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
        }
        .radar-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .radar-panel {
            border: 1px solid #333;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
        }
        .radar-screen {
            width: 100%;
            height: 300px;
            background: #000;
            border: 2px solid #00ff00;
            position: relative;
            overflow: hidden;
        }
        .tick-stream {
            height: 150px;
            background: #000;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #004400;
        }
        button.active {
            background: #006600;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .metric {
            text-align: center;
            padding: 10px;
            border: 1px solid #333;
            background: rgba(0, 50, 0, 0.3);
        }
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
        }
        .metric-label {
            font-size: 12px;
            color: #888;
        }
        .alert {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }
        .status-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .dormant { background: #333; }
        .watching { background: #ffff00; }
        .active { background: #ff0000; }
        .legend {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ ALGORITHMIC ACTIVITY RADAR</h1>
            <p>Detecting the Invisible Hand - Real-time Bot Activity Monitor</p>
            <div class="legend">
                <span><div class="status-indicator dormant"></div>DORMANT (Bots Sleeping)</span>
                <span><div class="status-indicator watching"></div>WATCHING (Light Touch)</span>
                <span><div class="status-indicator active"></div>ACTIVE (Full Response)</span>
            </div>
        </div>

        <div class="controls">
            <input type="text" id="symbolInput" placeholder="Enter symbol (e.g., BTCUSDT)" value="BTCUSDT" style="background: #003300; color: #00ff00; border: 1px solid #00ff00; padding: 8px; font-family: inherit;">
            <button id="connectBtn">CONNECT BINANCE</button>
            <button id="disconnectBtn">DISCONNECT</button>
            <button id="simulateBtn">SIMULATE MODE</button>
            <select id="sensitivity">
                <option value="low">Low Sensitivity</option>
                <option value="medium" selected>Medium Sensitivity</option>
                <option value="high">High Sensitivity</option>
            </select>
            <div id="connectionStatus" style="color: #ff0000; margin-left: 10px;">DISCONNECTED</div>
        </div>

        <div class="radar-grid">
            <div class="radar-panel">
                <h3>TICK PATTERN ANALYZER</h3>
                <canvas id="tickCanvas" class="tick-stream"></canvas>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="upticks">0</div>
                        <div class="metric-label">UPTICKS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="downticks">0</div>
                        <div class="metric-label">DOWNTICKS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="balance">0.0</div>
                        <div class="metric-label">BALANCE</div>
                    </div>
                </div>
            </div>

            <div class="radar-panel">
                <h3>ü§ñ BOT SIDE DETECTOR</h3>
                <div style="position: relative; height: 250px; background: #000; border: 2px solid #333; margin: 10px 0;">
                    <!-- Bot Battle Arena -->
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 80%; border: 1px solid #666;">
                        
                        <!-- LEFT SIDE - BEARS/SHORTS -->
                        <div id="bearSide" style="position: absolute; left: 0; top: 0; width: 50%; height: 100%; background: linear-gradient(to right, rgba(255,0,0,0.1), transparent); border-right: 1px solid #666; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                            <div style="color: #ff0000; font-size: 24px; margin-bottom: 10px;">üêª BEARS</div>
                            <div id="bearPower" style="color: #ff0000; font-size: 18px; font-weight: bold;">0%</div>
                            <div style="color: #ff6666; font-size: 12px;">BOT SHORTS</div>
                        </div>
                        
                        <!-- RIGHT SIDE - BULLS/LONGS -->
                        <div id="bullSide" style="position: absolute; right: 0; top: 0; width: 50%; height: 100%; background: linear-gradient(to left, rgba(0,255,0,0.1), transparent); display: flex; flex-direction: column; justify-content: center; align-items: center;">
                            <div style="color: #00ff00; font-size: 24px; margin-bottom: 10px;">üêÇ BULLS</div>
                            <div id="bullPower" style="color: #00ff00; font-size: 18px; font-weight: bold;">0%</div>
                            <div style="color: #66ff66; font-size: 12px;">BOT LONGS</div>
                        </div>
                        
                        <!-- CENTER BATTLE LINE -->
                        <div id="battleLine" style="position: absolute; left: 50%; top: 0; width: 3px; height: 100%; background: #ffff00; transform: translateX(-50%); transition: all 0.3s ease;"></div>
                        
                        <!-- BOT ACTIVITY INDICATOR -->
                        <div id="botIndicator" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 5px 10px; border: 1px solid #666; border-radius: 3px;">
                            <span style="color: #ffff00; font-size: 12px;">BOT ACTIVITY: </span>
                            <span id="botActivityLevel" style="color: #fff; font-size: 12px; font-weight: bold;">DORMANT</span>
                        </div>
                        
                    </div>
                    
                    <!-- Control Buttons -->
                    <div style="position: absolute; bottom: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between;">
                        <div style="color: #888; font-size: 10px;">INTENSITY: <span id="currentIntensity">0%</span></div>
                        <div style="color: #888; font-size: 10px;">BIAS: <span id="currentBias">NEUTRAL</span></div>
                    </div>
                </div>
                
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="botStatus">DORMANT</div>
                        <div class="metric-label">BOT STATUS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="responseTime">--</div>
                        <div class="metric-label">RESPONSE (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="intensity">0%</div>
                        <div class="metric-label">INTENSITY</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="botTrend">--</div>
                        <div class="metric-label">1MIN TREND</div>
                    </div>
                </div>
                <canvas id="historyCanvas" style="width: 100%; height: 80px; background: #000; border: 1px solid #333; margin: 10px 0;"></canvas>
            </div>
        </div>

        <div class="radar-panel">
            <h3>üìä TICK STRENGTH BATTLE - LAST 1 MINUTE</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 15px 0;">
                <div style="text-align: center; border: 2px solid #00ff00; padding: 15px; background: rgba(0,255,0,0.1);">
                    <div style="font-size: 24px; color: #00ff00;" id="uptickCount1m">0</div>
                    <div style="font-size: 12px;">UPTICKS</div>
                    <div style="font-size: 16px; margin: 5px 0;" id="uptickAvgSize1m">0.0</div>
                    <div style="font-size: 10px;">AVG SIZE</div>
                </div>
                
                <div style="text-align: center; border: 2px solid #ffff00; padding: 15px; background: rgba(255,255,0,0.1);">
                    <div style="font-size: 32px; color: #ffff00;" id="tickDelta">0</div>
                    <div style="font-size: 12px;">DELTA</div>
                    <div style="font-size: 16px; margin: 5px 0; color: #ffff00;" id="powerWinner">EVEN</div>
                    <div style="font-size: 10px;">POWER WINNER</div>
                </div>
                
                <div style="text-align: center; border: 2px solid #ff0000; padding: 15px; background: rgba(255,0,0,0.1);">
                    <div style="font-size: 24px; color: #ff0000;" id="downtickCount1m">0</div>
                    <div style="font-size: 12px;">DOWNTICKS</div>
                    <div style="font-size: 16px; margin: 5px 0;" id="downtickAvgSize1m">0.0</div>
                    <div style="font-size: 10px;">AVG SIZE</div>
                </div>
            </div>
            
            <div style="margin: 15px 0; padding: 10px; border: 1px solid #333; background: rgba(50,50,50,0.3);">
                <div style="font-size: 14px; text-align: center;">
                    <span style="color: #00ff00;">PATTERN: </span>
                    <span id="patternDescription" style="color: #ffff00;">ANALYZING...</span>
                </div>
            </div>
        </div>

        <div class="radar-panel">
            <h3>üìà 5-MINUTE COMPARISON</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="border: 1px solid #333; padding: 10px;">
                    <div style="color: #00ff00; font-size: 16px;">UPTICKS 5MIN</div>
                    <div style="font-size: 20px;" id="uptickCount5m">0</div>
                    <div style="font-size: 12px;">Avg Size: <span id="uptickAvgSize5m">0.0</span></div>
                    <div style="font-size: 12px; color: #888;">Trend: <span id="uptickTrend5m">--</span></div>
                </div>
                <div style="border: 1px solid #333; padding: 10px;">
                    <div style="color: #ff0000; font-size: 16px;">DOWNTICKS 5MIN</div>
                    <div style="font-size: 20px;" id="downtickCount5m">0</div>
                    <div style="font-size: 12px;">Avg Size: <span id="downtickAvgSize5m">0.0</span></div>
                    <div style="font-size: 12px; color: #888;">Trend: <span id="downtickTrend5m">--</span></div>
                </div>
            </div>
        </div>

        <div class="radar-panel">
            <h3>REACTION PATTERN DETECTION</h3>
            <canvas id="reactionCanvas" class="tick-stream"></canvas>
            <div class="alert" id="whaleAlert">
                üêã WHALE DETECTED! Large order triggering bot response patterns
            </div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="reactionDelay">--</div>
                    <div class="metric-label">REACTION DELAY</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="counterRatio">1.0</div>
                    <div class="metric-label">COUNTER RATIO</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="guardMode">PASSIVE</div>
                    <div class="metric-label">GUARD MODE</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AlgoRadar {
            constructor() {
                console.log("Starting AlgoRadar initialization...");
                
                this.isRunning = false;
                this.isConnected = false;
                this.ws = null;
                this.symbol = 'BTCUSDT';
                this.ticks = [];
                this.reactions = [];
                this.botActivity = 0;
                this.lastPrice = 100;
                this.lastVolume = 0;
                this.upticks = 0;
                this.downticks = 0;
                this.radarAngle = 0;
                this.tickBuffer = [];
                this.lastTradeTime = 0;
                this.activityHistory = []; // Store 1-minute history
                this.botPositionBias = 0; // Track bot directional bias
                this.historicalSamples = [];
                this.uptickHistory = []; // Store uptick strength over time
                this.downtickHistory = []; // Store downtick strength over time
                this.tickAnalysis = {
                    upticks1m: [],
                    downticks1m: [],
                    upticks5m: [],
                    downticks5m: []
                };
                
                // Wait for DOM to be ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        this.initialize();
                    });
                } else {
                    this.initialize();
                }
            }

            initialize() {
                console.log("Initializing canvases and events...");
                this.initCanvases();
                this.bindEvents();
                console.log("AlgoRadar initialized successfully!");
            }

            initCanvases() {
                this.tickCanvas = document.getElementById('tickCanvas');
                this.tickCtx = this.tickCanvas.getContext('2d');
                this.tickCanvas.width = this.tickCanvas.offsetWidth;
                this.tickCanvas.height = this.tickCanvas.offsetHeight;

                this.radarCanvas = document.getElementById('radarCanvas');
                this.radarCtx = this.radarCanvas.getContext('2d');
                this.radarCanvas.width = this.radarCanvas.offsetWidth;
                this.radarCanvas.height = this.radarCanvas.offsetHeight;

                this.reactionCanvas = document.getElementById('reactionCanvas');
                this.reactionCtx = this.reactionCanvas.getContext('2d');
                this.reactionCanvas.width = this.reactionCanvas.offsetWidth;
                this.reactionCanvas.height = this.reactionCanvas.offsetHeight;

                this.historyCanvas = document.getElementById('historyCanvas');
                this.historyCtx = this.historyCanvas.getContext('2d');
                this.historyCanvas.width = this.historyCanvas.offsetWidth;
                this.historyCanvas.height = this.historyCanvas.offsetHeight;
            }

            bindEvents() {
                console.log("Binding events...");
                
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const simulateBtn = document.getElementById('simulateBtn');
                
                if(connectBtn) connectBtn.onclick = () => this.connectBinance();
                if(disconnectBtn) disconnectBtn.onclick = () => this.disconnect();
                if(simulateBtn) simulateBtn.onclick = () => this.simulateMarket();
                
                console.log("Events bound, starting radar...");
                // Start radar automatically when page loads
                this.startRadar();
            }

            connectBinance() {
                this.symbol = document.getElementById('symbolInput').value.toUpperCase();
                
                if(this.ws) {
                    this.ws.close();
                }

                // Connect to Binance WebSocket for real-time trades
                const wsUrl = `wss://fstream.binance.com/ws/${this.symbol.toLowerCase()}@trade`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        document.getElementById('connectionStatus').textContent = `CONNECTED: ${this.symbol}`;
                        document.getElementById('connectionStatus').style.color = '#00ff00';
                        this.resetCounters();
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.processBinanceTrade(data);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        document.getElementById('connectionStatus').textContent = 'CONNECTION ERROR';
                        document.getElementById('connectionStatus').style.color = '#ff0000';
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        document.getElementById('connectionStatus').textContent = 'DISCONNECTED';
                        document.getElementById('connectionStatus').style.color = '#ff0000';
                    };
                    
                } catch(error) {
                    console.error('Failed to connect:', error);
                    document.getElementById('connectionStatus').textContent = 'FAILED TO CONNECT';
                    document.getElementById('connectionStatus').style.color = '#ff0000';
                }
            }

            disconnect() {
                if(this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.isConnected = false;
            }

            processBinanceTrade(data) {
                /*
                Binance trade data format:
                {
                    "e": "trade",
                    "E": 1672515782136,
                    "s": "BTCUSDT",
                    "t": 12345,
                    "p": "50000.00000000",
                    "q": "0.25000000",
                    "b": 88,
                    "a": 50,
                    "T": 1672515782136,
                    "m": true
                }
                */
                
                const price = parseFloat(data.p);
                const quantity = parseFloat(data.q);
                const isBuyerMaker = data.m; // true = sell order (market sell), false = buy order (market buy)
                const tradeTime = data.T;
                
                // Determine tick direction
                let direction = 0;
                if(this.lastPrice > 0) {
                    if(price > this.lastPrice) direction = 1;      // Uptick
                    else if(price < this.lastPrice) direction = -1; // Downtick
                    // else direction = 0 (no change)
                }
                
                // Calculate time between trades (speed detection)
                const timeDiff = this.lastTradeTime > 0 ? tradeTime - this.lastTradeTime : 0;
                
                // Analyze trade characteristics for bot detection
                const tradeType = this.analyzeTradeType(price, quantity, timeDiff, isBuyerMaker);
                
                const tick = {
                    timestamp: tradeTime,
                    direction,
                    size: quantity,
                    price: price,
                    volume: quantity * price,
                    timeDiff: timeDiff,
                    type: tradeType,
                    isBuyerMaker: isBuyerMaker
                };
                
                this.lastPrice = price;
                this.lastTradeTime = tradeTime;
                this.ticks.push(tick);
                
                if(direction > 0) this.upticks++;
                else if(direction < 0) this.downticks++;
                
                // Track bot positional bias
                this.updateBotPositionBias(tick);
                
                // Keep only last 100 ticks for performance
                if(this.ticks.length > 100) {
                    this.ticks.shift();
                }
                
                this.analyzeBotActivity();
                this.updateActivityHistory();
                this.updateUI();
            }

            analyzeTradeType(price, quantity, timeDiff, isBuyerMaker) {
                // Bot detection logic based on your observations
                
                // Very fast trades (< 50ms) often indicate algorithmic trading
                if(timeDiff < 50 && timeDiff > 0) {
                    return 'bot_response';
                }
                
                // Large quantity trades might be whales
                if(quantity > this.getAverageQuantity() * 5) {
                    return 'whale';
                }
                
                // Round numbers and specific sizes often indicate bots
                if(this.isRoundNumber(quantity) && timeDiff < 200) {
                    return 'bot_response';
                }
                
                return 'retail';
            }
            
            getAverageQuantity() {
                if(this.ticks.length < 10) return 1;
                const recent = this.ticks.slice(-10);
                const total = recent.reduce((sum, tick) => sum + tick.size, 0);
                return total / recent.length;
            }
            
            isRoundNumber(num) {
                // Check if number has few decimal places (bot characteristic)
                const str = num.toString();
                const decimals = str.split('.')[1];
                return !decimals || decimals.length <= 2;
            }

            resetCounters() {
                this.upticks = 0;
                this.downticks = 0;
                this.ticks = [];
                this.botActivity = 0;
                this.tickAnalysis = {
                    upticks1m: [],
                    downticks1m: [],
                    upticks5m: [],
                    downticks5m: []
                };
            }

            start() {
                this.isRunning = true;
                this.tick();
            }

            stop() {
                this.isRunning = false;
            }

            startRadar() {
                this.isRunning = true;
                this.tick();
            }

            simulateMarket() {
                console.log("Starting market simulation...");
                
                if(!this.isRunning) {
                    console.log("Radar not running, starting it first...");
                    this.startRadar();
                }
                
                // Reset data for clean simulation
                this.ticks = [];
                this.upticks = 0;
                this.downticks = 0;
                this.botActivity = 0;
                
                // Simulate normal retail trading
                console.log("Generating 20 retail trades...");
                for(let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        console.log(`Generating retail tick ${i+1}/20`);
                        this.generateTick('retail');
                    }, i * 200);
                }
                
                // Add some bot responses after a delay
                setTimeout(() => {
                    console.log("Generating whale activity...");
                    this.generateTick('whale');
                    setTimeout(() => {
                        console.log("Generating bot response...");
                        this.generateTick('bot_response');
                    }, 100);
                }, 4000);
                
                console.log("Market simulation started!");
            }

            triggerWhaleAlert() {
                document.getElementById('whaleAlert').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('whaleAlert').style.display = 'none';
                }, 5000);

                // Simulate whale order followed by bot response
                this.generateTick('whale');
                setTimeout(() => this.generateTick('bot_response'), 50);
            }

            generateTick(type = 'retail') {
                let direction, size;
                
                switch(type) {
                    case 'whale':
                        direction = Math.random() > 0.5 ? 1 : -1;
                        size = 5 + Math.random() * 10; // Large movement
                        break;
                    case 'bot_response':
                        direction = this.ticks.length > 0 ? -this.ticks[this.ticks.length - 1].direction : 1;
                        size = 2 + Math.random() * 3; // Measured counter-response
                        this.botActivity = Math.min(100, this.botActivity + 30);
                        break;
                    case 'retail':
                    default:
                        direction = Math.random() > 0.5 ? 1 : -1;
                        size = 0.5 + Math.random() * 2; // Small movements
                        break;
                }

                const now = Date.now(); // Use current time for simulated ticks
                const tick = {
                    timestamp: now,
                    direction,
                    size,
                    price: this.lastPrice + (direction * size),
                    type,
                    timeDiff: this.lastTradeTime > 0 ? now - this.lastTradeTime : 0
                };

                this.lastPrice = tick.price;
                this.lastTradeTime = now;
                
                // Store ticks for time-based analysis
                this.updateTickAnalysis(tick);
                
                this.ticks.push(tick);
                
                if(direction > 0) this.upticks++;
                else this.downticks++;

                // Keep only last 100 ticks
                if(this.ticks.length > 100) {
                    this.ticks.shift();
                }

                this.analyzeBotActivity();
                this.updateActivityHistory();
                this.updateTickStrengthAnalysis();
                this.updateUI();
            }

            analyzeBotActivity() {
                if(this.ticks.length < 5) return;

                const recent = this.ticks.slice(-10);
                let rapidCounters = 0;
                let balanceScore = 0;
                let botSignals = 0;
                let avgTimeDiff = 0;
                let timeCount = 0;

                for(let i = 1; i < recent.length; i++) {
                    const prev = recent[i-1];
                    const curr = recent[i];
                    
                    // Check for rapid counter-moves (your key observation)
                    if(prev.direction !== curr.direction && prev.direction !== 0 && curr.direction !== 0) {
                        if(curr.timeDiff < 100) { // Very fast response
                            rapidCounters++;
                        }
                    }
                    
                    // Calculate average time between trades
                    if(curr.timeDiff > 0) {
                        avgTimeDiff += curr.timeDiff;
                        timeCount++;
                    }
                    
                    // Count bot-type trades
                    if(curr.type === 'bot_response') {
                        botSignals++;
                    }
                }

                avgTimeDiff = timeCount > 0 ? avgTimeDiff / timeCount : 0;

                // Your "balancing act" detection
                const sensitivity = document.getElementById('sensitivity').value;
                let threshold = sensitivity === 'high' ? 15 : sensitivity === 'medium' ? 25 : 35;
                
                // Bot activity increases with rapid counters and bot signals
                if(rapidCounters > 0 || botSignals > 0) {
                    this.botActivity = Math.min(100, this.botActivity + (rapidCounters * 20) + (botSignals * 15));
                } else {
                    this.botActivity = Math.max(0, this.botActivity - 3);
                }

                // Update metrics
                const status = this.botActivity < 20 ? 'DORMANT' : 
                              this.botActivity < 60 ? 'WATCHING' : 'ACTIVE';
                document.getElementById('botStatus').textContent = status;
                document.getElementById('intensity').textContent = Math.round(this.botActivity) + '%';
                
                if(avgTimeDiff > 0) {
                    document.getElementById('responseTime').textContent = Math.round(avgTimeDiff) + 'ms';
                }
                
                // Update bot side detector
                this.updateBotSideDetector();
            }

            updateBotSideDetector() {
                const bearSide = document.getElementById('bearSide');
                const bullSide = document.getElementById('bullSide');
                const battleLine = document.getElementById('battleLine');
                const bearPower = document.getElementById('bearPower');
                const bullPower = document.getElementById('bullPower');
                const botActivityLevel = document.getElementById('botActivityLevel');
                const currentIntensity = document.getElementById('currentIntensity');
                const currentBias = document.getElementById('currentBias');
                
                // Calculate bot side preference
                const bias = this.botPositionBias;
                const activity = this.botActivity;
                
                // Update activity level
                if(activity < 20) {
                    botActivityLevel.textContent = 'DORMANT';
                    botActivityLevel.style.color = '#666';
                } else if(activity < 60) {
                    botActivityLevel.textContent = 'WATCHING';
                    botActivityLevel.style.color = '#ffff00';
                } else {
                    botActivityLevel.textContent = 'ACTIVE';
                    botActivityLevel.style.color = '#ff0000';
                }
                
                // Calculate power distribution
                let bearStrength = 50;
                let bullStrength = 50;
                
                if(Math.abs(bias) > 0.1) {
                    if(bias < 0) {
                        // Bots are bearish (suppressing price)
                        bearStrength = Math.min(90, 50 + Math.abs(bias) * 25);
                        bullStrength = 100 - bearStrength;
                    } else {
                        // Bots are bullish (supporting price)
                        bullStrength = Math.min(90, 50 + bias * 25);
                        bearStrength = 100 - bullStrength;
                    }
                }
                
                // Update power displays
                bearPower.textContent = Math.round(bearStrength) + '%';
                bullPower.textContent = Math.round(bullStrength) + '%';
                
                // Update visual intensity based on bot activity
                const bearOpacity = (activity / 100) * (bearStrength / 100);
                const bullOpacity = (activity / 100) * (bullStrength / 100);
                
                bearSide.style.background = `linear-gradient(to right, rgba(255,0,0,${bearOpacity}), transparent)`;
                bullSide.style.background = `linear-gradient(to left, rgba(0,255,0,${bullOpacity}), transparent)`;
                
                // Move battle line based on bias
                const linePosition = 50 + (bias * 20); // -2 to +2 bias = 10% to 90% position
                battleLine.style.left = Math.max(10, Math.min(90, linePosition)) + '%';
                
                // Update battle line color based on activity
                if(activity > 60) {
                    battleLine.style.background = '#ff0000';
                    battleLine.style.boxShadow = '0 0 10px #ff0000';
                } else if(activity > 30) {
                    battleLine.style.background = '#ffff00';
                    battleLine.style.boxShadow = '0 0 5px #ffff00';
                } else {
                    battleLine.style.background = '#666';
                    battleLine.style.boxShadow = 'none';
                }
                
                // Update bottom display
                currentIntensity.textContent = Math.round(activity) + '%';
                
                if(Math.abs(bias) < 0.1) {
                    currentBias.textContent = 'NEUTRAL';
                    currentBias.style.color = '#ffff00';
                } else if(bias < -0.1) {
                    currentBias.textContent = 'BEARISH';
                    currentBias.style.color = '#ff0000';
                } else {
                    currentBias.textContent = 'BULLISH';
                    currentBias.style.color = '#00ff00';
                }
            }

            updateBotPositionBias(tick) {
                // Analyze bot directional preference based on response patterns
                if(tick.type === 'bot_response') {
                    // If bots are responding with buys to sells (or vice versa), they're defending a position
                    if(tick.direction > 0) {
                        this.botPositionBias += 0.1; // Bots are supporting (likely long)
                    } else {
                        this.botPositionBias -= 0.1; // Bots are suppressing (likely short)
                    }
                    
                    // Keep bias in reasonable range
                    this.botPositionBias = Math.max(-2, Math.min(2, this.botPositionBias));
                }
                
                // Decay bias over time
                this.botPositionBias *= 0.995;
            }

            updateActivityHistory() {
                const now = Date.now();
                
                // Add current activity level to history
                this.activityHistory.push({
                    timestamp: now,
                    activity: this.botActivity,
                    bias: this.botPositionBias
                });
                
                // Keep only last 60 seconds of data
                this.activityHistory = this.activityHistory.filter(item => 
                    now - item.timestamp < 60000
                );
                
                // Calculate trend
                if(this.activityHistory.length > 10) {
                    const recent = this.activityHistory.slice(-10);
                    const older = this.activityHistory.slice(-20, -10);
                    
                    if(older.length > 0) {
                        const recentAvg = recent.reduce((sum, item) => sum + item.activity, 0) / recent.length;
                        const olderAvg = older.reduce((sum, item) => sum + item.activity, 0) / older.length;
                        
                        const trend = recentAvg - olderAvg;
                        
                        if(trend > 5) {
                            document.getElementById('botTrend').textContent = 'üìà RISING';
                            document.getElementById('botTrend').style.color = '#ff0000';
                        } else if(trend < -5) {
                            document.getElementById('botTrend').textContent = 'üìâ FALLING';
                            document.getElementById('botTrend').style.color = '#00ff00';
                        } else {
                            document.getElementById('botTrend').textContent = '‚û°Ô∏è STABLE';
                            document.getElementById('botTrend').style.color = '#ffff00';
                        }
                    }
                }
                
                this.updateBotWarning();
            }

            updateTickAnalysis(tick) {
                const now = tick.timestamp; // Use the actual trade timestamp from Binance
                
                // Add to appropriate arrays with timestamp
                const tickData = {
                    ...tick,
                    timestamp: now
                };
                
                if(tick.direction > 0) {
                    this.tickAnalysis.upticks1m.push(tickData);
                    this.tickAnalysis.upticks5m.push(tickData);
                } else if(tick.direction < 0) {
                    this.tickAnalysis.downticks1m.push(tickData);
                    this.tickAnalysis.downticks5m.push(tickData);
                }
                
                // Clean old data - 1 minute = 60000ms, 5 minutes = 300000ms
                const oneMinuteAgo = now - 60000;
                const fiveMinutesAgo = now - 300000;
                
                this.tickAnalysis.upticks1m = this.tickAnalysis.upticks1m.filter(t => t.timestamp > oneMinuteAgo);
                this.tickAnalysis.downticks1m = this.tickAnalysis.downticks1m.filter(t => t.timestamp > oneMinuteAgo);
                this.tickAnalysis.upticks5m = this.tickAnalysis.upticks5m.filter(t => t.timestamp > fiveMinutesAgo);
                this.tickAnalysis.downticks5m = this.tickAnalysis.downticks5m.filter(t => t.timestamp > fiveMinutesAgo);
                
                // Debug info
                console.log(`1min: ${this.tickAnalysis.upticks1m.length} up, ${this.tickAnalysis.downticks1m.length} down`);
                console.log(`5min: ${this.tickAnalysis.upticks5m.length} up, ${this.tickAnalysis.downticks5m.length} down`);
            }

            updateTickStrengthAnalysis() {
                // 1-minute analysis
                const upticks1m = this.tickAnalysis.upticks1m;
                const downticks1m = this.tickAnalysis.downticks1m;
                
                const uptickCount1m = upticks1m.length;
                const downtickCount1m = downticks1m.length;
                const delta = uptickCount1m - downtickCount1m;
                
                // Calculate average sizes
                const uptickAvgSize1m = upticks1m.length > 0 ? 
                    (upticks1m.reduce((sum, t) => sum + t.size, 0) / upticks1m.length).toFixed(3) : '0.000';
                const downtickAvgSize1m = downticks1m.length > 0 ? 
                    (downticks1m.reduce((sum, t) => sum + t.size, 0) / downticks1m.length).toFixed(3) : '0.000';
                
                // Update 1-minute display
                document.getElementById('uptickCount1m').textContent = uptickCount1m;
                document.getElementById('downtickCount1m').textContent = downtickCount1m;
                document.getElementById('uptickAvgSize1m').textContent = uptickAvgSize1m;
                document.getElementById('downtickAvgSize1m').textContent = downtickAvgSize1m;
                
                // Delta display
                const deltaElement = document.getElementById('tickDelta');
                deltaElement.textContent = delta > 0 ? `+${delta}` : delta.toString();
                deltaElement.style.color = delta > 0 ? '#00ff00' : delta < 0 ? '#ff0000' : '#ffff00';
                
                // Power winner
                const powerWinner = document.getElementById('powerWinner');
                const uptickPower = parseFloat(uptickAvgSize1m);
                const downtickPower = parseFloat(downtickAvgSize1m);
                
                if(uptickPower > downtickPower * 1.2) {
                    powerWinner.textContent = 'UPTICKS';
                    powerWinner.style.color = '#00ff00';
                } else if(downtickPower > uptickPower * 1.2) {
                    powerWinner.textContent = 'DOWNTICKS';
                    powerWinner.style.color = '#ff0000';
                } else {
                    powerWinner.textContent = 'EVEN';
                    powerWinner.style.color = '#ffff00';
                }
                
                // 5-minute analysis
                const upticks5m = this.tickAnalysis.upticks5m;
                const downticks5m = this.tickAnalysis.downticks5m;
                
                document.getElementById('uptickCount5m').textContent = upticks5m.length;
                document.getElementById('downtickCount5m').textContent = downticks5m.length;
                
                const uptickAvgSize5m = upticks5m.length > 0 ? 
                    (upticks5m.reduce((sum, t) => sum + t.size, 0) / upticks5m.length).toFixed(3) : '0.000';
                const downtickAvgSize5m = downticks5m.length > 0 ? 
                    (downticks5m.reduce((sum, t) => sum + t.size, 0) / downticks5m.length).toFixed(3) : '0.000';
                
                document.getElementById('uptickAvgSize5m').textContent = uptickAvgSize5m;
                document.getElementById('downtickAvgSize5m').textContent = downtickAvgSize5m;
                
                // Pattern description
                this.updatePatternDescription(uptickCount1m, downtickCount1m, uptickPower, downtickPower, delta);
            }

            updatePatternDescription(uptickCount, downtickCount, uptickPower, downtickPower, delta) {
                const pattern = document.getElementById('patternDescription');
                let description = '';
                
                if(Math.abs(delta) <= 2) {
                    description = 'BALANCED FIGHT - Equal pressure both sides';
                } else if(delta > 0) {
                    if(downtickPower > uptickPower * 1.3) {
                        description = 'MORE BUYS BUT SELLS ARE STRONGER - Weak buying pressure';
                    } else {
                        description = 'BUYING PRESSURE DOMINATES - Bulls in control';
                    }
                } else {
                    if(uptickPower > downtickPower * 1.3) {
                        description = 'MORE SELLS BUT BUYS ARE STRONGER - Strong support';
                    } else {
                        description = 'SELLING PRESSURE DOMINATES - Bears in control';
                    }
                }
                
                // Add bot context
                if(this.botActivity > 60) {
                    description += ' | ‚ö†Ô∏è BOTS ACTIVE';
                } else if(this.botActivity > 30) {
                    description += ' | üëÄ BOTS WATCHING';
                }
                
                pattern.textContent = description;
            }

            updateBotWarning() {
                const warningDiv = document.getElementById('botWarning');
                const warningText = document.getElementById('warningText');
                
                if(this.botActivity > 40 && Math.abs(this.botPositionBias) > 0.3) {
                    warningDiv.style.display = 'block';
                    
                    if(this.botPositionBias > 0.3) {
                        warningText.textContent = 'üö® DO NOT TRADE AGAINST LONG - BOTS ARE SUPPORTING UPSIDE';
                        warningDiv.style.borderColor = '#00ff00';
                        warningDiv.style.color = '#00ff00';
                        warningDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                    } else if(this.botPositionBias < -0.3) {
                        warningText.textContent = 'üö® DO NOT TRADE AGAINST SHORT - BOTS ARE SUPPRESSING UPSIDE';
                        warningDiv.style.borderColor = '#ff0000';
                        warningDiv.style.color = '#ff0000';
                        warningDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                    }
                } else {
                    warningDiv.style.display = 'none';
                }
            }

            updateUI() {
                document.getElementById('upticks').textContent = this.upticks;
                document.getElementById('downticks').textContent = this.downticks;
                
                const balance = this.upticks + this.downticks > 0 ? 
                    ((this.upticks - this.downticks) / (this.upticks + this.downticks)).toFixed(2) : 0;
                document.getElementById('balance').textContent = balance;

                const counterRatio = this.calculateCounterRatio();
                document.getElementById('counterRatio').textContent = counterRatio.toFixed(2);

                const guardMode = this.botActivity > 50 ? 'ACTIVE' : 'PASSIVE';
                document.getElementById('guardMode').textContent = guardMode;
            }

            calculateCounterRatio() {
                if(this.ticks.length < 4) return 1.0;
                
                const recent = this.ticks.slice(-4);
                let counters = 0;
                
                for(let i = 1; i < recent.length; i++) {
                    if(recent[i].direction !== recent[i-1].direction) {
                        counters++;
                    }
                }
                
                return counters / (recent.length - 1);
            }

            drawTickStream() {
                if(!this.tickCtx || !this.tickCanvas) return;
                
                const ctx = this.tickCtx;
                const canvas = this.tickCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();

                if(this.ticks.length < 2) return;

                const recent = this.ticks.slice(-50);
                const xStep = canvas.width / 50;
                
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                recent.forEach((tick, i) => {
                    const x = i * xStep;
                    const y = canvas.height / 2 - (tick.direction * tick.size * 10);
                    
                    if(i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Mark bot responses
                    if(tick.type === 'bot_response') {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    } else if(tick.type === 'whale') {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(x - 3, y - 3, 6, 6);
                    }
                });
                
                ctx.strokeStyle = '#00ff00';
                ctx.stroke();
            }

            drawRadar() {
                // Removed - replaced with bot side detector
            }

            drawReactionPattern() {
                if(!this.reactionCtx || !this.reactionCanvas) return;
                
                const ctx = this.reactionCtx;
                const canvas = this.reactionCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if(this.ticks.length < 2) return;
                
                const recent = this.ticks.slice(-20);
                const xStep = canvas.width / 20;
                
                recent.forEach((tick, i) => {
                    const x = i * xStep;
                    const height = Math.abs(tick.size) * 10;
                    const y = tick.direction > 0 ? canvas.height / 2 - height : canvas.height / 2;
                    
                    if(tick.type === 'bot_response') {
                        ctx.fillStyle = '#ff0000';
                    } else if(tick.type === 'whale') {
                        ctx.fillStyle = '#ffff00';
                    } else {
                        ctx.fillStyle = '#00ff00';
                    }
                    
                    ctx.fillRect(x, y, xStep - 1, height);
                });
            }

            drawActivityHistory() {
                if(!this.historyCtx || !this.historyCanvas) return;
                
                const ctx = this.historyCtx;
                const canvas = this.historyCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if(this.activityHistory.length < 2) return;
                
                const maxActivity = 100;
                const xStep = canvas.width / 60; // 60 seconds
                const now = Date.now();
                
                // Draw grid lines
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for(let i = 0; i <= 4; i++) {
                    const y = (i / 4) * canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw activity line
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                this.activityHistory.forEach((item, i) => {
                    const ageSeconds = (now - item.timestamp) / 1000;
                    const x = canvas.width - (ageSeconds * xStep);
                    const y = canvas.height - ((item.activity / maxActivity) * canvas.height);
                    
                    if(i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Color code based on trend
                    if(item.activity > 60) {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                    } else if(item.activity > 30) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                    }
                });
                
                ctx.stroke();
                
                // Draw current level indicator
                const currentY = canvas.height - ((this.botActivity / maxActivity) * canvas.height);
                ctx.fillStyle = this.botActivity > 60 ? '#ff0000' : this.botActivity > 30 ? '#ffff00' : '#00ff00';
                ctx.fillRect(canvas.width - 5, currentY - 2, 5, 4);
            }

            tick() {
                if(!this.isRunning) return;
                
                // Only generate simulated ticks if not connected to Binance
                if(!this.isConnected) {
                    this.generateTick();
                }
                
                this.drawTickStream();
                this.drawReactionPattern();
                this.drawActivityHistory();
                
                setTimeout(() => this.tick(), this.isConnected ? 100 : 500);
            }
        }

        const radar = new AlgoRadar();
    </script>
</body>
</html>
