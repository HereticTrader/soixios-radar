<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Activity Radar</title>
    <style>
        body {
            font-family: 'Consolas', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #004400;
        }
        button.active {
            background: #006600;
        }
        input {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px;
            font-family: inherit;
        }
        .panel {
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.8);
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .metric-box {
            text-align: center;
            border: 2px solid;
            padding: 15px;
            margin: 5px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
        }
        .metric-label {
            font-size: 12px;
            margin-top: 5px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #666;
            text-align: center;
        }
        .bot-arena {
            position: relative;
            height: 200px;
            background: #000;
            border: 2px solid #333;
            margin: 10px 0;
        }
        .bear-side, .bull-side {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .bear-side {
            left: 0;
            border-right: 1px solid #666;
        }
        .bull-side {
            right: 0;
        }
        .battle-line {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: #ffff00;
            left: 50%;
            transform: translateX(-50%);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ ALGORITHMIC ACTIVITY RADAR</h1>
            <p>Detecting the Invisible Hand - Real-time Bot Activity Monitor</p>
        </div>

        <div class="controls">
            <input type="text" id="symbolInput" placeholder="BTCUSDT" value="BTCUSDT">
            <button id="connectBtn">CONNECT BINANCE</button>
            <button id="disconnectBtn">DISCONNECT</button>
            <button id="simulateBtn">SIMULATE MODE</button>
            <div id="status" style="color: #ff0000; margin-left: 10px;">DISCONNECTED</div>
        </div>

        <div class="grid">
            <!-- TICK STRENGTH BATTLE -->
            <div class="panel">
                <h3>üìä TICK STRENGTH BATTLE - LAST 1 MINUTE</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                    <div class="metric-box" style="border-color: #00ff00; background: rgba(0,255,0,0.1);">
                        <div class="metric-value" style="color: #00ff00;" id="uptickCount">0</div>
                        <div class="metric-label">UPTICKS</div>
                        <div style="font-size: 14px; margin: 5px 0;" id="uptickAvg">0.0</div>
                        <div style="font-size: 10px;">AVG SIZE</div>
                    </div>
                    
                    <div class="metric-box" style="border-color: #ffff00; background: rgba(255,255,0,0.1);">
                        <div class="metric-value" style="color: #ffff00;" id="tickDelta">0</div>
                        <div class="metric-label">DELTA</div>
                        <div style="font-size: 14px; margin: 5px 0; color: #ffff00;" id="powerWinner">EVEN</div>
                        <div style="font-size: 10px;">POWER WINNER</div>
                    </div>
                    
                    <div class="metric-box" style="border-color: #ff0000; background: rgba(255,0,0,0.1);">
                        <div class="metric-value" style="color: #ff0000;" id="downtickCount">0</div>
                        <div class="metric-label">DOWNTICKS</div>
                        <div style="font-size: 14px; margin: 5px 0;" id="downtickAvg">0.0</div>
                        <div style="font-size: 10px;">AVG SIZE</div>
                    </div>
                </div>
                
                <div class="status">
                    <span style="color: #00ff00;">PATTERN: </span>
                    <span id="patternText" style="color: #ffff00;">ANALYZING...</span>
                </div>
            </div>

            <!-- BOT SIDE DETECTOR -->
            <div class="panel">
                <h3>ü§ñ BOT SIDE DETECTOR</h3>
                <div class="bot-arena">
                    <div class="bear-side" id="bearSide" style="background: linear-gradient(to right, rgba(255,0,0,0.1), transparent);">
                        <div style="color: #ff0000; font-size: 20px;">üêª BEARS</div>
                        <div id="bearPower" style="color: #ff0000; font-size: 16px; font-weight: bold;">50%</div>
                        <div style="color: #ff6666; font-size: 10px;">BOT SHORTS</div>
                    </div>
                    
                    <div class="bull-side" id="bullSide" style="background: linear-gradient(to left, rgba(0,255,0,0.1), transparent);">
                        <div style="color: #00ff00; font-size: 20px;">üêÇ BULLS</div>
                        <div id="bullPower" style="color: #00ff00; font-size: 16px; font-weight: bold;">50%</div>
                        <div style="color: #66ff66; font-size: 10px;">BOT LONGS</div>
                    </div>
                    
                    <div class="battle-line" id="battleLine"></div>
                    
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 5px 10px; border: 1px solid #666;">
                        <span style="color: #ffff00; font-size: 12px;">BOT STATUS: </span>
                        <span id="botStatus" style="color: #fff; font-size: 12px; font-weight: bold;">DORMANT</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <div class="status">
                        <div id="botIntensity" style="font-size: 18px;">0%</div>
                        <div style="font-size: 10px;">INTENSITY</div>
                    </div>
                    <div class="status">
                        <div id="responseTime" style="font-size: 18px;">--</div>
                        <div style="font-size: 10px;">RESPONSE (ms)</div>
                    </div>
                    <div class="status">
                        <div id="botBias" style="font-size: 18px;">NEUTRAL</div>
                        <div style="font-size: 10px;">BIAS</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- WARNING ALERT -->
        <div id="warningAlert" style="display: none; background: rgba(255, 165, 0, 0.3); border: 1px solid #ffa500; color: #ffa500; padding: 10px; margin: 10px 0; text-align: center;">
            ‚ö†Ô∏è <span id="warningText">TRADE WARNING</span>
        </div>
    </div>

    <script>
        class SimpleRadar {
            constructor() {
                console.log("üéØ Starting Simple Radar...");
                
                // Basic properties
                this.isConnected = false;
                this.isRunning = false;
                this.ws = null;
                this.symbol = 'BTCUSDT';
                
                // Data storage
                this.upticks1m = [];
                this.downticks1m = [];
                this.botActivity = 0;
                this.botBias = 0;
                this.lastPrice = 50000;
                this.lastTime = 0;
                
                // Bind events
                this.bindEvents();
                
                // Start the radar
                this.start();
                
                console.log("‚úÖ Simple Radar initialized!");
            }
            
            bindEvents() {
                document.getElementById('connectBtn').onclick = () => this.connectBinance();
                document.getElementById('disconnectBtn').onclick = () => this.disconnect();
                document.getElementById('simulateBtn').onclick = () => this.simulate();
            }
            
            start() {
                this.isRunning = true;
                this.tick();
                console.log("üöÄ Radar started!");
            }
            
            simulate() {
                console.log("üéÆ Starting simulation...");
                
                // Clear existing data
                this.upticks1m = [];
                this.downticks1m = [];
                this.botActivity = 0;
                this.botBias = 0;
                
                // Generate 30 simulated trades
                for(let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        this.generateTrade();
                    }, i * 300);
                }
                
                console.log("‚úÖ Simulation started!");
            }
            
            generateTrade() {
                const now = Date.now();
                const direction = Math.random() > 0.5 ? 1 : -1;
                const size = 0.1 + Math.random() * 2;
                const price = this.lastPrice + (direction * (Math.random() * 5));
                
                // Create trade object
                const trade = {
                    timestamp: now,
                    price: price,
                    size: size,
                    direction: direction,
                    timeDiff: this.lastTime > 0 ? now - this.lastTime : 0
                };
                
                this.lastPrice = price;
                this.lastTime = now;
                
                // Store in appropriate array
                if(direction > 0) {
                    this.upticks1m.push(trade);
                } else {
                    this.downticks1m.push(trade);
                }
                
                // Clean old data (older than 1 minute)
                const oneMinuteAgo = now - 60000;
                this.upticks1m = this.upticks1m.filter(t => t.timestamp > oneMinuteAgo);
                this.downticks1m = this.downticks1m.filter(t => t.timestamp > oneMinuteAgo);
                
                // Simulate bot activity
                if(Math.random() < 0.3) { // 30% chance of bot response
                    this.botActivity = Math.min(100, this.botActivity + 20);
                    this.botBias += direction * 0.1;
                } else {
                    this.botActivity = Math.max(0, this.botActivity - 5);
                }
                
                // Keep bias in range
                this.botBias = Math.max(-2, Math.min(2, this.botBias * 0.95));
                
                console.log(`üìà Trade: ${direction > 0 ? 'UP' : 'DOWN'} ${size.toFixed(3)} at ${price.toFixed(2)}`);
                
                this.updateDisplay();
            }
            
            connectBinance() {
                this.symbol = document.getElementById('symbolInput').value.toUpperCase();
                
                if(this.ws) this.ws.close();
                
                // Use multiple Binance endpoints for better reliability
                const endpoints = [
                    `wss://fstream.binance.com/ws/${this.symbol.toLowerCase()}@trade`,
                    `wss://stream.binance.com:9443/ws/${this.symbol.toLowerCase()}@trade`,
                    `wss://stream.binance.com:443/ws/${this.symbol.toLowerCase()}@trade`
                ];
                
                this.connectWithFallback(endpoints, 0);
            }
            
            connectWithFallback(endpoints, index) {
                if(index >= endpoints.length) {
                    document.getElementById('status').textContent = 'ALL ENDPOINTS FAILED';
                    document.getElementById('status').style.color = '#ff0000';
                    return;
                }
                
                const wsUrl = endpoints[index];
                console.log(`üîó Trying endpoint ${index + 1}: ${wsUrl}`);
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        document.getElementById('status').textContent = `CONNECTED: ${this.symbol} (EP${index + 1})`;
                        document.getElementById('status').style.color = '#00ff00';
                        console.log(`‚úÖ Connected to ${this.symbol} via endpoint ${index + 1}`);
                        
                        // Clear old data on new connection
                        this.upticks1m = [];
                        this.downticks1m = [];
                        this.botActivity = 0;
                        this.botBias = 0;
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.processBinanceTrade(data);
                        } catch(error) {
                            console.error('Failed to parse trade data:', error);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error(`‚ùå Endpoint ${index + 1} error:`, error);
                        document.getElementById('status').textContent = `EP${index + 1} FAILED, TRYING NEXT...`;
                        document.getElementById('status').style.color = '#ffff00';
                        
                        // Try next endpoint after a short delay
                        setTimeout(() => {
                            this.connectWithFallback(endpoints, index + 1);
                        }, 1000);
                    };
                    
                    this.ws.onclose = (event) => {
                        this.isConnected = false;
                        console.log(`üîå Connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                        
                        if(event.code === 1006 || event.code === 1000) {
                            // Normal close or network issue - try to reconnect
                            document.getElementById('status').textContent = 'RECONNECTING...';
                            document.getElementById('status').style.color = '#ffff00';
                            
                            setTimeout(() => {
                                console.log('üîÑ Attempting reconnection...');
                                this.connectWithFallback(endpoints, 0);
                            }, 3000);
                        } else {
                            document.getElementById('status').textContent = 'DISCONNECTED';
                            document.getElementById('status').style.color = '#ff0000';
                        }
                    };
                    
                    // Connection timeout
                    setTimeout(() => {
                        if(this.ws && this.ws.readyState === WebSocket.CONNECTING) {
                            console.log(`‚è∞ Endpoint ${index + 1} timeout`);
                            this.ws.close();
                            this.connectWithFallback(endpoints, index + 1);
                        }
                    }, 5000);
                    
                } catch(error) {
                    console.error(`‚ùå Failed to create WebSocket for endpoint ${index + 1}:`, error);
                    this.connectWithFallback(endpoints, index + 1);
                }
            }
            
            processBinanceTrade(data) {
                // Validate data structure
                if(!data.p || !data.q || !data.T) {
                    console.warn('Invalid trade data received:', data);
                    return;
                }
                
                const price = parseFloat(data.p);
                const quantity = parseFloat(data.q);
                const timestamp = data.T;
                
                // Validate parsed values
                if(isNaN(price) || isNaN(quantity) || price <= 0 || quantity <= 0) {
                    console.warn('Invalid price/quantity:', price, quantity);
                    return;
                }
                
                let direction = 0;
                if(this.lastPrice > 0) {
                    if(price > this.lastPrice) direction = 1;
                    else if(price < this.lastPrice) direction = -1;
                }
                
                if(direction !== 0) {
                    const trade = {
                        timestamp: timestamp,
                        price: price,
                        size: quantity,
                        direction: direction,
                        timeDiff: this.lastTime > 0 ? timestamp - this.lastTime : 0
                    };
                    
                    this.lastPrice = price;
                    this.lastTime = timestamp;
                    
                    // Store trade
                    if(direction > 0) {
                        this.upticks1m.push(trade);
                    } else {
                        this.downticks1m.push(trade);
                    }
                    
                    // Clean old data
                    const oneMinuteAgo = timestamp - 60000;
                    this.upticks1m = this.upticks1m.filter(t => t.timestamp > oneMinuteAgo);
                    this.downticks1m = this.downticks1m.filter(t => t.timestamp > oneMinuteAgo);
                    
                    // Analyze bot activity
                    if(trade.timeDiff < 100 && trade.timeDiff > 0) {
                        this.botActivity = Math.min(100, this.botActivity + 15);
                        this.botBias += direction * 0.05;
                    } else {
                        this.botActivity = Math.max(0, this.botActivity - 2);
                    }
                    
                    this.botBias *= 0.999; // Slow decay
                    
                    this.updateDisplay();
                    
                    // Debug output every 10th trade
                    if((this.upticks1m.length + this.downticks1m.length) % 10 === 0) {
                        console.log(`üìä 1min: ${this.upticks1m.length} up, ${this.downticks1m.length} down | Bot: ${Math.round(this.botActivity)}%`);
                    }
                }
            }
            
            disconnect() {
                if(this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.isConnected = false;
            }
            
            updateDisplay() {
                // Update tick counts
                const uptickCount = this.upticks1m.length;
                const downtickCount = this.downticks1m.length;
                const delta = uptickCount - downtickCount;
                
                document.getElementById('uptickCount').textContent = uptickCount;
                document.getElementById('downtickCount').textContent = downtickCount;
                
                // Calculate averages
                const uptickAvg = uptickCount > 0 ? 
                    (this.upticks1m.reduce((sum, t) => sum + t.size, 0) / uptickCount).toFixed(3) : '0.000';
                const downtickAvg = downtickCount > 0 ? 
                    (this.downticks1m.reduce((sum, t) => sum + t.size, 0) / downtickCount).toFixed(3) : '0.000';
                
                document.getElementById('uptickAvg').textContent = uptickAvg;
                document.getElementById('downtickAvg').textContent = downtickAvg;
                
                // Delta
                const deltaElement = document.getElementById('tickDelta');
                deltaElement.textContent = delta > 0 ? `+${delta}` : delta.toString();
                deltaElement.style.color = delta > 0 ? '#00ff00' : delta < 0 ? '#ff0000' : '#ffff00';
                
                // Power winner
                const uptickPower = parseFloat(uptickAvg);
                const downtickPower = parseFloat(downtickAvg);
                const powerWinner = document.getElementById('powerWinner');
                
                if(uptickPower > downtickPower * 1.2) {
                    powerWinner.textContent = 'UPTICKS';
                    powerWinner.style.color = '#00ff00';
                } else if(downtickPower > uptickPower * 1.2) {
                    powerWinner.textContent = 'DOWNTICKS';
                    powerWinner.style.color = '#ff0000';
                } else {
                    powerWinner.textContent = 'EVEN';
                    powerWinner.style.color = '#ffff00';
                }
                
                // Pattern description
                let pattern = '';
                if(Math.abs(delta) <= 2) {
                    pattern = 'BALANCED FIGHT - Equal pressure both sides';
                } else if(delta > 0) {
                    pattern = downtickPower > uptickPower * 1.3 ? 
                        'MORE BUYS BUT SELLS STRONGER - Weak buying' : 
                        'BUYING PRESSURE DOMINATES - Bulls control';
                } else {
                    pattern = uptickPower > downtickPower * 1.3 ? 
                        'MORE SELLS BUT BUYS STRONGER - Strong support' : 
                        'SELLING PRESSURE DOMINATES - Bears control';
                }
                
                if(this.botActivity > 60) pattern += ' | ‚ö†Ô∏è BOTS ACTIVE';
                else if(this.botActivity > 30) pattern += ' | üëÄ BOTS WATCHING';
                
                document.getElementById('patternText').textContent = pattern;
                
                // Bot status
                const status = this.botActivity < 20 ? 'DORMANT' : 
                              this.botActivity < 60 ? 'WATCHING' : 'ACTIVE';
                document.getElementById('botStatus').textContent = status;
                document.getElementById('botIntensity').textContent = Math.round(this.botActivity) + '%';
                
                // Bot side detector
                this.updateBotSide();
                
                // Warnings
                this.updateWarnings();
            }
            
            updateBotSide() {
                const bias = this.botBias;
                const activity = this.botActivity;
                
                // Calculate power distribution
                let bearStrength = 50;
                let bullStrength = 50;
                
                if(Math.abs(bias) > 0.1) {
                    if(bias < 0) {
                        bearStrength = Math.min(90, 50 + Math.abs(bias) * 20);
                        bullStrength = 100 - bearStrength;
                    } else {
                        bullStrength = Math.min(90, 50 + bias * 20);
                        bearStrength = 100 - bullStrength;
                    }
                }
                
                document.getElementById('bearPower').textContent = Math.round(bearStrength) + '%';
                document.getElementById('bullPower').textContent = Math.round(bullStrength) + '%';
                
                // Battle line position
                const linePosition = 50 + (bias * 15);
                document.getElementById('battleLine').style.left = Math.max(10, Math.min(90, linePosition)) + '%';
                
                // Battle line color
                const battleLine = document.getElementById('battleLine');
                if(activity > 60) {
                    battleLine.style.background = '#ff0000';
                    battleLine.style.boxShadow = '0 0 10px #ff0000';
                } else if(activity > 30) {
                    battleLine.style.background = '#ffff00';
                    battleLine.style.boxShadow = '0 0 5px #ffff00';
                } else {
                    battleLine.style.background = '#666';
                    battleLine.style.boxShadow = 'none';
                }
                
                // Bias display
                const biasElement = document.getElementById('botBias');
                if(Math.abs(bias) < 0.1) {
                    biasElement.textContent = 'NEUTRAL';
                    biasElement.style.color = '#ffff00';
                } else if(bias < -0.1) {
                    biasElement.textContent = 'BEARISH';
                    biasElement.style.color = '#ff0000';
                } else {
                    biasElement.textContent = 'BULLISH';
                    biasElement.style.color = '#00ff00';
                }
            }
            
            updateWarnings() {
                const warningAlert = document.getElementById('warningAlert');
                const warningText = document.getElementById('warningText');
                
                if(this.botActivity > 50 && Math.abs(this.botBias) > 0.3) {
                    warningAlert.style.display = 'block';
                    
                    if(this.botBias > 0.3) {
                        warningText.textContent = 'üö® DO NOT TRADE AGAINST LONG - BOTS SUPPORTING UPSIDE';
                        warningAlert.style.borderColor = '#00ff00';
                        warningAlert.style.color = '#00ff00';
                        warningAlert.style.background = 'rgba(0, 255, 0, 0.2)';
                    } else {
                        warningText.textContent = 'üö® DO NOT TRADE AGAINST SHORT - BOTS SUPPRESSING UPSIDE';
                        warningAlert.style.borderColor = '#ff0000';
                        warningAlert.style.color = '#ff0000';
                        warningAlert.style.background = 'rgba(255, 0, 0, 0.2)';
                    }
                } else {
                    warningAlert.style.display = 'none';
                }
            }
            
            tick() {
                if(!this.isRunning) return;
                
                // Update display every tick
                this.updateDisplay();
                
                setTimeout(() => this.tick(), 1000);
            }
        }

        // Start the radar when page loads
        window.addEventListener('load', () => {
            console.log("üéØ Page loaded, starting radar...");
            window.radar = new SimpleRadar();
        });
    </script>
</body>
</html>
