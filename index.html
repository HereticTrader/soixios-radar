<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Activity Radar</title>
    <style>
        body {
            font-family: 'Consolas', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
        }
        .radar-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .radar-panel {
            border: 1px solid #333;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
        }
        .radar-screen {
            width: 100%;
            height: 300px;
            background: #000;
            border: 2px solid #00ff00;
            position: relative;
            overflow: hidden;
        }
        .tick-stream {
            height: 150px;
            background: #000;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #004400;
        }
        button.active {
            background: #006600;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .metric {
            text-align: center;
            padding: 10px;
            border: 1px solid #333;
            background: rgba(0, 50, 0, 0.3);
        }
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
        }
        .metric-label {
            font-size: 12px;
            color: #888;
        }
        .alert {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }
        .status-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .dormant { background: #333; }
        .watching { background: #ffff00; }
        .active { background: #ff0000; }
        .legend {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ ALGORITHMIC ACTIVITY RADAR</h1>
            <p>Detecting the Invisible Hand - Real-time Bot Activity Monitor</p>
            <div class="legend">
                <span><div class="status-indicator dormant"></div>DORMANT (Bots Sleeping)</span>
                <span><div class="status-indicator watching"></div>WATCHING (Light Touch)</span>
                <span><div class="status-indicator active"></div>ACTIVE (Full Response)</span>
            </div>
        </div>

        <div class="controls">
            <input type="text" id="symbolInput" placeholder="Enter symbol (e.g., BTCUSDT)" value="BTCUSDT" style="background: #003300; color: #00ff00; border: 1px solid #00ff00; padding: 8px; font-family: inherit;">
            <button id="connectBtn">CONNECT BINANCE</button>
            <button id="disconnectBtn">DISCONNECT</button>
            <button id="simulateBtn">SIMULATE MODE</button>
            <select id="sensitivity">
                <option value="low">Low Sensitivity</option>
                <option value="medium" selected>Medium Sensitivity</option>
                <option value="high">High Sensitivity</option>
            </select>
            <div id="connectionStatus" style="color: #ff0000; margin-left: 10px;">DISCONNECTED</div>
        </div>

        <div class="radar-grid">
            <div class="radar-panel">
                <h3>TICK PATTERN ANALYZER</h3>
                <canvas id="tickCanvas" class="tick-stream"></canvas>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="upticks">0</div>
                        <div class="metric-label">UPTICKS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="downticks">0</div>
                        <div class="metric-label">DOWNTICKS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="balance">0.0</div>
                        <div class="metric-label">BALANCE</div>
                    </div>
                </div>
            </div>

            <div class="radar-panel">
                <h3>BOT ACTIVITY RADAR</h3>
                <canvas id="radarCanvas" class="radar-screen"></canvas>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="botStatus">DORMANT</div>
                        <div class="metric-label">BOT STATUS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="responseTime">--</div>
                        <div class="metric-label">RESPONSE (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="intensity">0%</div>
                        <div class="metric-label">INTENSITY</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="radar-panel">
            <h3>REACTION PATTERN DETECTION</h3>
            <canvas id="reactionCanvas" class="tick-stream"></canvas>
            <div class="alert" id="whaleAlert">
                üêã WHALE DETECTED! Large order triggering bot response patterns
            </div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="reactionDelay">--</div>
                    <div class="metric-label">REACTION DELAY</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="counterRatio">1.0</div>
                    <div class="metric-label">COUNTER RATIO</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="guardMode">PASSIVE</div>
                    <div class="metric-label">GUARD MODE</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AlgoRadar {
            constructor() {
                this.isRunning = false;
                this.isConnected = false;
                this.ws = null;
                this.symbol = 'BTCUSDT';
                this.ticks = [];
                this.reactions = [];
                this.botActivity = 0;
                this.lastPrice = 100;
                this.lastVolume = 0;
                this.upticks = 0;
                this.downticks = 0;
                this.radarAngle = 0;
                this.tickBuffer = [];
                this.lastTradeTime = 0;
                
                this.initCanvases();
                this.bindEvents();
            }

            initCanvases() {
                this.tickCanvas = document.getElementById('tickCanvas');
                this.tickCtx = this.tickCanvas.getContext('2d');
                this.tickCanvas.width = this.tickCanvas.offsetWidth;
                this.tickCanvas.height = this.tickCanvas.offsetHeight;

                this.radarCanvas = document.getElementById('radarCanvas');
                this.radarCtx = this.radarCanvas.getContext('2d');
                this.radarCanvas.width = this.radarCanvas.offsetWidth;
                this.radarCanvas.height = this.radarCanvas.offsetHeight;

                this.reactionCanvas = document.getElementById('reactionCanvas');
                this.reactionCtx = this.reactionCanvas.getContext('2d');
                this.reactionCanvas.width = this.reactionCanvas.offsetWidth;
                this.reactionCanvas.height = this.reactionCanvas.offsetHeight;
            }

            bindEvents() {
                document.getElementById('connectBtn').onclick = () => this.connectBinance();
                document.getElementById('disconnectBtn').onclick = () => this.disconnect();
                document.getElementById('simulateBtn').onclick = () => this.simulateMarket();
                
                // Start radar automatically when connected
                this.startRadar();
            }

            connectBinance() {
                this.symbol = document.getElementById('symbolInput').value.toUpperCase();
                
                if(this.ws) {
                    this.ws.close();
                }

                // Connect to Binance WebSocket for real-time trades
                const wsUrl = `wss://fstream.binance.com/ws/${this.symbol.toLowerCase()}@trade`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        document.getElementById('connectionStatus').textContent = `CONNECTED: ${this.symbol}`;
                        document.getElementById('connectionStatus').style.color = '#00ff00';
                        this.resetCounters();
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.processBinanceTrade(data);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        document.getElementById('connectionStatus').textContent = 'CONNECTION ERROR';
                        document.getElementById('connectionStatus').style.color = '#ff0000';
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        document.getElementById('connectionStatus').textContent = 'DISCONNECTED';
                        document.getElementById('connectionStatus').style.color = '#ff0000';
                    };
                    
                } catch(error) {
                    console.error('Failed to connect:', error);
                    document.getElementById('connectionStatus').textContent = 'FAILED TO CONNECT';
                    document.getElementById('connectionStatus').style.color = '#ff0000';
                }
            }

            disconnect() {
                if(this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.isConnected = false;
            }

            processBinanceTrade(data) {
                /*
                Binance trade data format:
                {
                    "e": "trade",
                    "E": 1672515782136,
                    "s": "BTCUSDT",
                    "t": 12345,
                    "p": "50000.00000000",
                    "q": "0.25000000",
                    "b": 88,
                    "a": 50,
                    "T": 1672515782136,
                    "m": true
                }
                */
                
                const price = parseFloat(data.p);
                const quantity = parseFloat(data.q);
                const isBuyerMaker = data.m; // true = sell order (market sell), false = buy order (market buy)
                const tradeTime = data.T;
                
                // Determine tick direction
                let direction = 0;
                if(this.lastPrice > 0) {
                    if(price > this.lastPrice) direction = 1;      // Uptick
                    else if(price < this.lastPrice) direction = -1; // Downtick
                    // else direction = 0 (no change)
                }
                
                // Calculate time between trades (speed detection)
                const timeDiff = this.lastTradeTime > 0 ? tradeTime - this.lastTradeTime : 0;
                
                // Analyze trade characteristics for bot detection
                const tradeType = this.analyzeTradeType(price, quantity, timeDiff, isBuyerMaker);
                
                const tick = {
                    timestamp: tradeTime,
                    direction,
                    size: quantity,
                    price: price,
                    volume: quantity * price,
                    timeDiff: timeDiff,
                    type: tradeType,
                    isBuyerMaker: isBuyerMaker
                };
                
                this.lastPrice = price;
                this.lastTradeTime = tradeTime;
                this.ticks.push(tick);
                
                if(direction > 0) this.upticks++;
                else if(direction < 0) this.downticks++;
                
                // Keep only last 100 ticks for performance
                if(this.ticks.length > 100) {
                    this.ticks.shift();
                }
                
                this.analyzeBotActivity();
                this.updateUI();
            }

            analyzeTradeType(price, quantity, timeDiff, isBuyerMaker) {
                // Bot detection logic based on your observations
                
                // Very fast trades (< 50ms) often indicate algorithmic trading
                if(timeDiff < 50 && timeDiff > 0) {
                    return 'bot_response';
                }
                
                // Large quantity trades might be whales
                if(quantity > this.getAverageQuantity() * 5) {
                    return 'whale';
                }
                
                // Round numbers and specific sizes often indicate bots
                if(this.isRoundNumber(quantity) && timeDiff < 200) {
                    return 'bot_response';
                }
                
                return 'retail';
            }
            
            getAverageQuantity() {
                if(this.ticks.length < 10) return 1;
                const recent = this.ticks.slice(-10);
                const total = recent.reduce((sum, tick) => sum + tick.size, 0);
                return total / recent.length;
            }
            
            isRoundNumber(num) {
                // Check if number has few decimal places (bot characteristic)
                const str = num.toString();
                const decimals = str.split('.')[1];
                return !decimals || decimals.length <= 2;
            }

            resetCounters() {
                this.upticks = 0;
                this.downticks = 0;
                this.ticks = [];
                this.botActivity = 0;
            }

            start() {
                this.isRunning = true;
                this.tick();
            }

            stop() {
                this.isRunning = false;
            }

            startRadar() {
                this.isRunning = true;
                this.tick();
            }

            simulateMarket() {
                // Simulate normal retail trading
                for(let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.generateTick('retail');
                    }, i * 100);
                }
            }

            triggerWhaleAlert() {
                document.getElementById('whaleAlert').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('whaleAlert').style.display = 'none';
                }, 5000);

                // Simulate whale order followed by bot response
                this.generateTick('whale');
                setTimeout(() => this.generateTick('bot_response'), 50);
            }

            generateTick(type = 'retail') {
                let direction, size;
                
                switch(type) {
                    case 'whale':
                        direction = Math.random() > 0.5 ? 1 : -1;
                        size = 5 + Math.random() * 10; // Large movement
                        break;
                    case 'bot_response':
                        direction = this.ticks.length > 0 ? -this.ticks[this.ticks.length - 1].direction : 1;
                        size = 2 + Math.random() * 3; // Measured counter-response
                        this.botActivity = Math.min(100, this.botActivity + 30);
                        break;
                    case 'retail':
                    default:
                        direction = Math.random() > 0.5 ? 1 : -1;
                        size = 0.5 + Math.random() * 2; // Small movements
                        break;
                }

                const tick = {
                    timestamp: Date.now(),
                    direction,
                    size,
                    price: this.lastPrice + (direction * size),
                    type
                };

                this.lastPrice = tick.price;
                this.ticks.push(tick);
                
                if(direction > 0) this.upticks++;
                else this.downticks++;

                // Keep only last 100 ticks
                if(this.ticks.length > 100) {
                    this.ticks.shift();
                }

                this.analyzeBotActivity();
                this.updateUI();
            }

            analyzeBotActivity() {
                if(this.ticks.length < 5) return;

                const recent = this.ticks.slice(-10);
                let rapidCounters = 0;
                let balanceScore = 0;
                let botSignals = 0;
                let avgTimeDiff = 0;
                let timeCount = 0;

                for(let i = 1; i < recent.length; i++) {
                    const prev = recent[i-1];
                    const curr = recent[i];
                    
                    // Check for rapid counter-moves (your key observation)
                    if(prev.direction !== curr.direction && prev.direction !== 0 && curr.direction !== 0) {
                        if(curr.timeDiff < 100) { // Very fast response
                            rapidCounters++;
                        }
                    }
                    
                    // Calculate average time between trades
                    if(curr.timeDiff > 0) {
                        avgTimeDiff += curr.timeDiff;
                        timeCount++;
                    }
                    
                    // Count bot-type trades
                    if(curr.type === 'bot_response') {
                        botSignals++;
                    }
                }

                avgTimeDiff = timeCount > 0 ? avgTimeDiff / timeCount : 0;

                // Your "balancing act" detection
                const sensitivity = document.getElementById('sensitivity').value;
                let threshold = sensitivity === 'high' ? 15 : sensitivity === 'medium' ? 25 : 35;
                
                // Bot activity increases with rapid counters and bot signals
                if(rapidCounters > 0 || botSignals > 0) {
                    this.botActivity = Math.min(100, this.botActivity + (rapidCounters * 20) + (botSignals * 15));
                } else {
                    this.botActivity = Math.max(0, this.botActivity - 3);
                }

                // Update metrics
                const status = this.botActivity < 20 ? 'DORMANT' : 
                              this.botActivity < 60 ? 'WATCHING' : 'ACTIVE';
                document.getElementById('botStatus').textContent = status;
                document.getElementById('intensity').textContent = Math.round(this.botActivity) + '%';
                
                if(avgTimeDiff > 0) {
                    document.getElementById('responseTime').textContent = Math.round(avgTimeDiff) + 'ms';
                }
            }

            updateUI() {
                document.getElementById('upticks').textContent = this.upticks;
                document.getElementById('downticks').textContent = this.downticks;
                
                const balance = this.upticks + this.downticks > 0 ? 
                    ((this.upticks - this.downticks) / (this.upticks + this.downticks)).toFixed(2) : 0;
                document.getElementById('balance').textContent = balance;

                const counterRatio = this.calculateCounterRatio();
                document.getElementById('counterRatio').textContent = counterRatio.toFixed(2);

                const guardMode = this.botActivity > 50 ? 'ACTIVE' : 'PASSIVE';
                document.getElementById('guardMode').textContent = guardMode;
            }

            calculateCounterRatio() {
                if(this.ticks.length < 4) return 1.0;
                
                const recent = this.ticks.slice(-4);
                let counters = 0;
                
                for(let i = 1; i < recent.length; i++) {
                    if(recent[i].direction !== recent[i-1].direction) {
                        counters++;
                    }
                }
                
                return counters / (recent.length - 1);
            }

            drawTickStream() {
                const ctx = this.tickCtx;
                const canvas = this.tickCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();

                if(this.ticks.length < 2) return;

                const recent = this.ticks.slice(-50);
                const xStep = canvas.width / 50;
                
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                recent.forEach((tick, i) => {
                    const x = i * xStep;
                    const y = canvas.height / 2 - (tick.direction * tick.size * 10);
                    
                    if(i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Mark bot responses
                    if(tick.type === 'bot_response') {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    } else if(tick.type === 'whale') {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(x - 3, y - 3, 6, 6);
                    }
                });
                
                ctx.strokeStyle = '#00ff00';
                ctx.stroke();
            }

            drawRadar() {
                const ctx = this.radarCtx;
                const canvas = this.radarCanvas;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 20;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw radar circles
                ctx.strokeStyle = '#003300';
                ctx.lineWidth = 1;
                for(let r = radius / 4; r <= radius; r += radius / 4) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw radar lines
                for(let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius
                    );
                    ctx.stroke();
                }
                
                // Draw sweeping radar line
                this.radarAngle += 0.02;
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(this.radarAngle) * radius,
                    centerY + Math.sin(this.radarAngle) * radius
                );
                ctx.stroke();
                
                // Draw bot activity blips
                if(this.botActivity > 20) {
                    const blipRadius = (this.botActivity / 100) * radius;
                    const blipAngle = this.radarAngle + Math.random() * 0.5 - 0.25;
                    
                    ctx.fillStyle = this.botActivity > 60 ? '#ff0000' : '#ffff00';
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(blipAngle) * blipRadius,
                        centerY + Math.sin(blipAngle) * blipRadius,
                        3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawReactionPattern() {
                const ctx = this.reactionCtx;
                const canvas = this.reactionCanvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if(this.ticks.length < 2) return;
                
                const recent = this.ticks.slice(-20);
                const xStep = canvas.width / 20;
                
                recent.forEach((tick, i) => {
                    const x = i * xStep;
                    const height = Math.abs(tick.size) * 10;
                    const y = tick.direction > 0 ? canvas.height / 2 - height : canvas.height / 2;
                    
                    if(tick.type === 'bot_response') {
                        ctx.fillStyle = '#ff0000';
                    } else if(tick.type === 'whale') {
                        ctx.fillStyle = '#ffff00';
                    } else {
                        ctx.fillStyle = '#00ff00';
                    }
                    
                    ctx.fillRect(x, y, xStep - 1, height);
                });
            }

            tick() {
                if(!this.isRunning) return;
                
                // Only generate simulated ticks if not connected to Binance
                if(!this.isConnected) {
                    this.generateTick();
                }
                
                this.drawTickStream();
                this.drawRadar();
                this.drawReactionPattern();
                
                setTimeout(() => this.tick(), this.isConnected ? 100 : 500);
            }
        }

        const radar = new AlgoRadar();
    </script>
</body>
</html>
